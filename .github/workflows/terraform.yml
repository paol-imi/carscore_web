name: "Run Terraform"

# On PUSH to main:
#   0) Run terraform fmt
#       (ensure conformity to Terraform style guide)
#   1) Compute Terraform variables and set the TF_WORKSPACE environment variable
#       (TF_WORKSPACE is used by Terraform CLI to select the Terraform Cloud
#       workspace to use)
#   2) Create the workspace of the Branch on Terraform Cloud if it not exists
#       (We run this step even if the workspace should already exists, since we
#       may have deleted the workspace manually)
#   3) Run Terraform init
#       (setup the Terraform Cloud backend)
#   4) Run Terraform validate
#       (ensure syntax is correct)
#   5) Run Terraform apply
#       (deploy the infrastructure)
#
# On PULL REQUEST opened (reopened) or updated to main:
#   0) Run terraform fmt
#       (ensure conformity to Terraform style guide)
#   1) Compute Terraform variables and set the TF_WORKSPACE environment variable
#       (TF_WORKSPACE is used by Terraform CLI to select the Terraform Cloud
#       workspace to use)
#   2) Create the workspace of the Branch on Terraform Cloud if it not exists
#       (We run this step even if the workspace should already exists, since we
#       may have deleted the workspace manually)
#   3) Run Terraform init
#       (setup the Terraform Cloud backend)
#   4) Run Terraform validate
#       (ensure syntax is correct)
#   5) Run Terraform plan, continue if plan fails
#       (show what will be deployed)
#   6) Create of update a comment on the PR with the plan
#       (even if plan failed)
#   7) If the plan failed, exit with error
#   8) Run Terraform apply
#       (deploy the infrastructure)
#
# On PULL REQUEST closed to main:
#   1) Compute Terraform variables and set the TF_WORKSPACE environment variable
#       (TF_WORKSPACE is used by Terraform CLI to select the Terraform Cloud
#       workspace to use)
#   3) Run Terraform init
#       (setup the Terraform Cloud backend)
#   4) Run Terraform destroy, then delete the workspace

on:
  push:
    branches: [main] # [main, dev]
    # TODO: Find a way to reference this file without hardcoding the path
    paths: ["terraform/**", "backend/**", ".github/workflows/terraform.yml"]
  pull_request:
    branches: [main] # [main, dev]
    paths: ["terraform/**", "backend/**", ".github/workflows/terraform.yml"]
    # TODO: the "edited" tag will make the workflow trigger when base branch is
    #       changed (which is what we want), but it will also trigger when the
    #       PR is edited (which we don't want). We leave this edge case open for
    #       now to avoid over-complicating this workflow.
    types: [opened, synchronize, reopened, closed]

env:
  ## Terraform configuration
  TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
  DEPENDENT_WORKSPACE_PREFIX: cars-workspace-branch-
  SHARED_WORKSPACE_NAME: cars-workspace-shared
  # Backend configuration
  GRADLE_BUILD_PATH: terraform/branch-dependent/dist
  JAVA_VERSION: 11

# The aws group ensures that only one workflow at a time can modify the AWS
# infrastructure (even if Terraform cloud is already handling concurrent jobs).
concurrency: aws-${{ github.ref }}

jobs:
  environment:
    name: "Environment"
    runs-on: ubuntu-latest
    outputs:
      BRANCH: ${{ jobs.environment.outputs.BRANCH }}
      IS_BACKEND_CHANGED: ${{ steps.check_backend_changes.outputs.BRANCH }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Compute Branch variables
        id: set_env
        run: |
          REF="${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}"
          BRANCH=$(basename "$REF")
          echo "BRANCH=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Check for changes in backend
        id: check_backend_changes
        if: github.event.action != 'closed'
        run: |
          if git diff --quiet HEAD^ HEAD -- backend ; then
            echo "IS_BACKEND_CHANGED=true" >> "$GITHUB_OUTPUT"
          else
            echo "IS_BACKEND_CHANGED=false" >> "$GITHUB_OUTPUT"
          fi

  backend:
    name: "Backend"
    needs: [environment]
    runs-on: ubuntu-latest
    steps:
      - name: Cache Build
        id: cache-build
        if: github.event.action != 'closed'
        uses: actions/cache@v3
        with:
          # the docs say that "the default branch cache is available to other branches".
          path: ${{ env.GRADLE_BUILD_PATH }}
          key: build-output-${{ jobs.environment.outputs.BRANCH }}

      - name: Setup java
        if: github.event.action != 'closed' && !(steps.cache-build.outputs.cache-hit == 'true' && jobs.environment.outputs.CHANGED == 'false')
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}

      - name: Setup gradle
        if: github.event.action != 'closed' && !(steps.cache-build.outputs.cache-hit == 'true' && jobs.environment.outputs.CHANGED == 'false')
        uses: gradle/gradle-build-action@v2

      - name: Build backend
        if: github.event.action != 'closed' && !(steps.cache-build.outputs.cache-hit == 'true' && jobs.environment.outputs.CHANGED == 'false')
        working-directory: backend
        run: ./gradlew build

  # The terraform job is responsible for managing the Terraform lifecycle
  terraform:
    name: "Terraform"
    runs-on: ubuntu-latest
    needs: [environment, backend]
    strategy:
      # Hack to minimize code
      max-parallel: 1
      matrix:
        module: ["shared", "branch-dependent"]
    defaults:
      run:
        working-directory: terraform/${{ matrix.module }}
    permissions:
      # Allow the workflow to write to the pull request
      pull-requests: write
    steps:
      - name: environment
        id: environment
        run: |
          DEPENDENT_WORKSPACE=${{ env.DEPENDENT_WORKSPACE_PREFIX }}${{ jobs.environment.outputs.BRANCH }}

          if {{ matrix.module }} == "branch-dependent" ; then      
            WORKSPACE=$DEPENDENT_WORKSPACE
            [[ "$BRANCH" == "main" ]] && RESOURCES_PREFIX="" || RESOURCES_PREFIX="$BRANCH"
            TERRAFORM_INPUT="-input=false -var-file='.tfvars' -var='RESOURCES_PREFIX=$RESOURCES_PREFIX'"
          else
            WORKSPACE=$SHARED_WORKSPACE_NAME
            TERRAFORM_INPUT="-input=false -var-file='.tfvars'"
          fi

          echo "TERRAFORM_INPUT=$TERRAFORM_INPUT" >> "$GITHUB_OUTPUT"
          echo 'TF_WORKSPACE='$WORKSPACE >> $GITHUB_ENV
          echo 'WORKSPACE='$WORKSPACE >> $GITHUB_OUTPUT

      # Create the workspace if it does not exist
      - name: Create workspace
        if: github.event.action != 'closed'
        run: |
          curl \
            --header "Authorization: Bearer ${{ env.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            --request POST \
            --data '{
              "data": {
                "attributes": {
                  "name": "${{ steps.environment.outputs.WORKSPACE }}"
                },
                "type": "workspaces"
              }
            }' \
            https://app.terraform.io/api/v2/organizations/cars-organization/workspaces
        continue-on-error: true

      # The setup-terraform action is responsible for installing Terraform and
      # configuring the Terraform CLI to use the Terraform Cloud API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          cli_config_credentials_token: ${{ env.TF_API_TOKEN }}

      # Run the Terraform fmt command to check the Terraform code for formatting
      - name: Terraform Format
        id: fmt
        if: github.event.action != 'closed'
        run: terraform fmt -check

      # Run the Terraform init command to initialize the Terraform working directory
      - name: Terraform Init
        id: init
        run: terraform init

      # Run the Terraform validate command to validate the Terraform code
      - name: Terraform Validate
        id: validate
        if: github.event.action != 'closed'
        run: terraform validate -no-color

      # Run the Terraform plan command to generate a Terraform execution plan
      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request' && github.event.action != 'closed'
        # The -var-file option is used to pass the Terraform variables file
        # The -var option is used to pass the ENV variable
        run: terraform plan -no-color ${{ steps.environment.outputs.TERRAFORM_INPUT }}
        # Continue the workflow even if the Terraform plan command fails, so that
        # the Terraform plan can be viewed in the pull request.
        # The workflow will be killed later
        continue-on-error: true

      # Create a comment on the pull request with the Terraform plan
      - name: Update Pull Request
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request' && github.event.action != 'closed'
        env:
          PLAN: ${{ steps.plan.outputs.stdout }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Build the Comment body
            const output = `### Terraform ${{ matrix.module }} plan

            #### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`terraform\n
            ${process.env.PLAN}
            \`\`\`

            </details>800.513.328

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            // Get the list of comments on the pull request
            const commits = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Check if the comment already exists
            const comment = commits.data.find(
              (comment) => comment.body.includes('### Terraform ${{ matrix.module }} plan'));

            // Update or create the comment
            if (comment) {
              await github.rest.issues.updateComment({
                comment_id: comment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              })
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              })
            }

      # Fail the workflow if the Terraform plan step fails, this allows the pull
      # request message to be written before the workflow is killed
      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      # Run the Terraform apply command to apply the Terraform execution plan
      - name: Terraform Apply
        if: github.event.action != 'closed' && !(${{ matrix.module }} == 'shared' && ${{ jobs.environment.outputs.BRANCH}} != 'main')
        run: terraform apply -auto-approve ${{ steps.environment.outputs.TERRAFORM_INPUT }}

      # Run the Terraform destroy command to destroy the Terraform execution plan
      - name: Terraform Destroy
        if: github.event.action == 'closed'
        run: |
          terraform destroy -auto-approve ${{ steps.environment.outputs.TERRAFORM_INPUT }}
          TF_WORKSPACE=${{ env.SHARED_WORKSPACE_NAME }}
          terraform workspace select ${{ env.SHARED_WORKSPACE_NAME }}
          terraform workspace delete ${{ steps.environment.outputs.WORKSPACE }}
